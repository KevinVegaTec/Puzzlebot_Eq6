// This script converts "encoders" messages into proper odom messages.

#include <math.h>
#include <ros/console.h>
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_datatypes.h>

#include <nav_msgs/Odometry.h>
//#include "base_control/StampedEncoders.h"
#include <geometry_msgs/Quaternion.h>


// Define Velocity struct for clarity in the code.
struct Velocity {
    double x = 0.0;
    double y = 0.0;
    double th = 0.0;
};

// Define Position struct for clarity in the code.
struct Position {
    double x = 0.0;
    double y = 0.0;
    double th = 0.0;
};

// Initialize global variables.
int front_left = 0;
int front_right = 0;
int back_left = 0;
int back_right = 0;
double dt_front = 0.000001;
double dt_back = 0.000001;

// Initialize constants.
const double wheel_radius = 0.05;
const double wheel_circumference = wheel_radius * 2 * M_PI;
const double encoder_resolution = 4320;
// The robot constant is defined by the sum of the distance between 
// the wheel's x-coord & the origin, and the y-coord & the origin.
const double robot_constant = 0.19/2;
const double dist_per_tick = wheel_circumference / encoder_resolution;
const bool publish_odom_message = true;

// Function to save front encoder data to global variables.
void feCallBack(const base_control::StampedEncoders::ConstPtr& msg) {
    ROS_INFO_STREAM("INFO RECEIVED \n *Encoders");
    front_left = msg->encoders.left_wheel;
    front_right = msg->encoders.right_wheel;
    dt_front = msg->encoders.time_delta;
}

// Function to initalize Odometry Message.
void initializeOdometryMessage(nav_msgs::Odometry &odom){
    // Define frame constants.
    odom.header.frame_id = "odom";
    odom.child_frame_id = "base_footprint";
    
    // Define postiion constants.
    odom.pose.pose.position.z = 0.0;
    
    // Define velocity constants.
    odom.twist.twist.linear.z = 0.0;
    odom.twist.twist.angular.x = 0.0;
    odom.twist.twist.angular.y = 0.0;
    
    // Define pose covariance constants.
    odom.pose.covariance[0] = 1e3;
    odom.pose.covariance[7] = 1e3;
    odom.pose.covariance[14] = 1e100;
    odom.pose.covariance[21] = 1e100;
    odom.pose.covariance[28] = 1e100;
    odom.pose.covariance[35] = 1e3;

    // Define twist covariance constants.
    odom.twist.covariance[0] = 1e3;
    odom.twist.covariance[7] = 1e3;
    odom.twist.covariance[14] = 1e100;
    odom.twist.covariance[21] = 1e100;
    odom.twist.covariance[28] = 1e100;
    odom.twist.covariance[35] = 1e3;
}

// Function to initalize Odometry Transform.
void initializeOdometryTransform(geometry_msgs::TransformStamped &odom_trans){
    // Define frame constants.
    odom_trans.header.frame_id = "odom";
    odom_trans.child_frame_id = "base_footprint";
    
    // Define postiion constants.
    odom_trans.transform.translation.z = 0.0;
}

// Function to compute robot velocity.
void computeRobotVelocity(Velocity &robot_velocity){
    // Compute the velocities of each wheel.
    const double v_fl = (front_left * dist_per_tick) / dt_front;
    const double v_fr = (front_right * dist_per_tick) / dt_front;

    // Compute the overall velocity of the robot.
    robot_velocity.x = (v_fl + v_fr) / 2.0;
    robot_velocity.y = (v_fl - v_fr) / 2.0;
    robot_velocity.th = (-v_fl + v_fr) / (2.0 * robot_constant);
}

// Function to compute robot displacement.
void computeRobotDisplacement(const Velocity robot_velocity, Position &robot_position, const double avg_dt){
    // Compute the change in displacement.
    const double delta_x = robot_velocity.x * avg_dt;
    const double delta_y = robot_velocity.y * avg_dt;
    const double delta_th = robot_velocity.th * avg_dt;

    // Compute the overall displacement.
    robot_position.x = robot_position.x + delta_x;
    robot_position.y = robot_position.y + delta_y;
    robot_position.th = robot_position.th + delta_th;
}

int main(int argc, char** argv) {
    // Initialize ROS.
    ros::init(argc, argv, "base_odom");
    ROS_INFO_STREAM("*Node initiated");
    ros::NodeHandle ros_node;
    ros::Publisher odom_pub = ros_node.advertise<nav_msgs::Odometry>("/puzzlebot/odom", 60);
    ros::Subscriber fr_enc = ros_node.subscribe("/puzzlebot/front/encoders", 100, feCallBack);
    tf::TransformBroadcaster odom_broadcaster;
    ros::Time current_time = ros::Time::now();
    
    // Checks the loop at a rate of 25Hz -> 0.04 seconds.
    ros::Rate r(25.0);

    // Initialize odometry message.
    nav_msgs::Odometry odom;
    initializeOdometryMessage(odom);

    // Initialize odometry transform.
    geometry_msgs::TransformStamped odom_trans;
    initializeOdometryTransform(odom_trans);

    // Initialize robot velocity variables.
    Velocity robot_velocity;

    // Initialize robot displacement variables.
    Position robot_displacement;

    while (ros_node.ok()) {
        // Saves the current system time.
        current_time = ros::Time::now();

        // Calculates the average time between encoder counts for the front encoders.
        const double avg_dt = dt_front;

        // Skips the rest of the loop if for some reason no time has passed between encoder counts.
        if (avg_dt == 0) {
            continue;
        }
        
        // Compute robot overall velocity.
        computeRobotVelocity(robot_velocity);

        // Compute robot overall displacement.
        computeRobotDisplacement(robot_velocity, robot_displacement, avg_dt);

        // Create quaternion created from yaw.
        geometry_msgs::Quaternion odom_quat = tf::createQuaternionMsgFromYaw(robot_displacement.th);
    
        // Update odometry message stamp.
        odom.header.stamp = current_time;
        
        // Update odometry transform stamp.
        odom_trans.header.stamp = current_time;
        
        // Update odometry message position.
        odom.pose.pose.position.x = robot_displacement.x;
        odom.pose.pose.position.y = robot_displacement.y;
        odom.pose.pose.orientation = odom_quat;
        
        // Update odometry transform position.
        odom_trans.transform.translation.x = robot_displacement.x;
        odom_trans.transform.translation.y = robot_displacement.y;
        odom_trans.transform.rotation = odom_quat;

        // Update odometry velocity.
        odom.twist.twist.linear.x = robot_velocity.x;
        odom.twist.twist.linear.y = robot_velocity.y;
        odom.twist.twist.angular.z = robot_velocity.th;

        // Publish odometry message.
        if (publish_odom_message) {
            odom_pub.publish(odom);
        }
        
        // Publish odometry transform.
        odom_broadcaster.sendTransform(odom_trans);

        ros::spinOnce();
        r.sleep();
    }
}
